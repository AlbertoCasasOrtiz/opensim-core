#ifndef TOMU_MUSCLEREDUNDANCYSOLVER_H
#define TOMU_MUSCLEREDUNDANCYSOLVER_H

#include <OpenSim/OpenSim.h>

namespace OpenSim {

// TODO if this solves for the activity of any actuator, then it should not
// be called "muscle" redundancy solver.
class MuscleRedundancySolver : public OpenSim::Object {
OpenSim_DECLARE_CONCRETE_OBJECT(MuscleRedundancySolver, OpenSim::Object);
public:

    struct Solution {
        /// The excitation trajectories for all enabled (appliesForce) muscles.
        /// This will be empty if there are no enabled muscles.
        TimeSeriesTable excitation;
        /// The activation trajectories for all enabled (appliesForce) muscles.
        /// This will be empty if there are no enabled muscles.
        TimeSeriesTable activation;
        /// The fiber length trajectories for all enabled (appliesForce)
        /// muscles, normalized by optimal fiber length.
        /// This will be empty if there are no enabled muscles.
        TimeSeriesTable norm_fiber_length;
        /// The fiber length trajectories for all enabled (appliesForce)
        /// muscles, normalized by max contraction velocity (e.g., within
        /// [-1, 1]). This will be empty if there are no enabled muscles.
        TimeSeriesTable norm_fiber_velocity;
        /// The control for enabled (appliesForce) CoordinateActuators, etc.
        /// This will be empty if there are no CoordinateActuators, etc.
        /// enabled.
        TimeSeriesTable other_controls;
        /// Write the solution to a series of OpenSim Storage files (one
        /// for each table) whose paths begin with `prefix`. Empty tables are
        /// not written.
        void write(const std::string& prefix) const;
    };

    //OpenSim_DECLARE_PROPERTY(model_file, std::string,
    //    "Path to a model file (.osim).");
    //OpenSim_DECLARE_PROPERTY(kinematics_file, std::string,
    //    "Path to a Storage (.sto) file containing kinematics.");

    MuscleRedundancySolver();

    const Model& getModel() const {
        return _model;
    }
    /// Set the model whose muscles will be used to achieve the desired
    /// motion.
    void setModel(const Model& model) {
        _model = model;
        _model.finalizeFromProperties();
    }

    const TimeSeriesTable& getKinematicsData() const {
        return _kinematics;
    }
    /// Set the kinematics (joint angles) to achieve.
    /// The table should contain generalized coordinates and generalized speeds,
    /// as is generated by StatesTrajectory::exportToTable().
    void setKinematicsData(const TimeSeriesTable& kinematics) {
        if (kinematics.getNumRows() == 0) {
            throw std::runtime_error(
                    "The provided kinematics table has no rows.");
        }
        _kinematics = kinematics;
    }

    Solution solve();

private:
    GCVSplineSet computeInverseDynamics() const;
    Model _model;
    // TODO make this a StatesTrajectory?
    TimeSeriesTable _kinematics;

    // To determine which actuators enter the optimal control problem.
    // TODO std::vector<std::string> _actuatorsToUse;
};

} // namespace OpenSim

#endif // TOMU_MUSCLEREDUNDANCYSOLVER_H
