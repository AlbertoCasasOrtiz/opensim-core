namespace OpenSim {
/**

@page mocoimplguide Moco Implementation Guide

@tableofcontents

TODO AccelerationMotion
TODO DiscreteForces
TODO Why we need two OpenSim Models.

This guide explains the organization of code in Moco and how direct collocation
schemes are implemented using an OpenSim model.

@section implorg Organization of classes

Moco is organized as pairs of Problem and Solver classes.

@image html MocoImplementationDiagram.svg width=700px

MocoProblem describes a direct collocation problem using an OpenSim Model, and
MocoSolver is an abstract class for solving MocoProblems. Moco provides two
MocoSolvers: MocoTropterSolver and MocoCasADiSolver. MocoTropterSolver contains
a problem-solver pair for optimal control problems: TropterProblem (which
derives from tropter::Problem) and tropter::DirectCollocation. To solve the
optimal control problem, tropter::DirectCollocation employs a problem-solver
pair for generic nonlinear optimization: tropter::Transcription (which derives
from tropter::optimization::Problem) and tropter::optimization::Solver. The
MocoCasADiSolver employs the problem-solver pair of MocoCasOCProblem (deriving
from CasOC::Problem) and CasOC::Solver.

These pairs of classes allow a separation between how a user specifies a
problem and the method used to solve the problem.
The MocoProblem class contains only user input and describes the physical
optimal control problem. The MocoSolver classes allow the user to configure the
numerical method used to solve the problem.

@subsection implmocoproblemrep The MocoProblemRep class

The MocoSolver interacts with the MocoProblem through the intermediate class
MocoProblemRep. This class exists to:

1. Validate the MocoProblem and cache useful quantities.
2. Provide functionality, such as evaluating cost terms.
3. Prevent solvers from accidentally editing any user input; the solvers do not
have access to the original MocoProblem.

The MocoProblemRep allows us not to worry about using invalid caches. Every
time the Solver solves a problem, a new MocoProblemRep is created, ensuring that
the most up-to-date settings in MocoProblem are obeyed.

@section impldiverse Supporting diverse formulations using OpenSim and Simbody

The following problem formulations in Moco require careful consideration:

1. kinematic constraints,
2. expressing multibody dynamics as implicit differential equations, and
3. prescribing kinematics.

Next, we describe how Moco handles each of these formulations.

There are multiple ways to use a SimTK::System to compute desired quantities.
For example, SimTK::SimbodyMatterSubsystem contains many useful operators.
However, the conventional way to use a SimTK::System is to realize the system's
SimTK::State through the Position, Velocity, Dynamics, and Acceleration stages.
Using the SimTK::System in this way ensures that all calculations use the same
input variables (this is described more concretely later). While the three
formulations above could more easily be achieved using the
SimTK::SimbodyMatterSubsystem operators, we employ strategies to handle these
formulations using the standard realization stages. The goal of the following
sections is to explain how we work the formulations above into the realization
stages.

@subsection implkincon Kinematic constraints

When performing musculoskeletal simulations, we must satisfy the following
equations:

\f[
    \begin{alignat*}{2}
         M(q, p)\dot{u} + G(q, p)^T \lambda &= f_{\textrm{app}}(t, y, x, p) - f_{\textrm{bias}}(q, u, p) \\
         0 &= \phi(q, p) \\
         \dot{z}(t) &= f_{\textrm{aux}}(t, y, x, \lambda, p) \\
    \end{alignat*}
\f]

The common way to solve these equations is to differentiate the kinematic
constraints until generalized accelerations appear linearly, and then solve for
generalized accelerations and Lagrange multipliers. This solve occurs when
realizing a SimTK::System to SimTK::Stage::Acceleration.

\f[
    \begin{alignat*}{2}
    \begin{bmatrix}
    M(q, p) & G(q, p)^T \\
    G(q, p) & 0
    \end{bmatrix}
    \begin{bmatrix}
    \dot{u} \\
    \lambda
    \end{bmatrix}
    &=
    \begin{bmatrix}
        f_{\textrm{app}}(t, y, x, p) - f_{\textrm{bias}}(q, u, p) \\
        b(q, u)
        \end{bmatrix} \\
         \dot{z}(t) &= f_{\textrm{aux}}(t, y, x, \lambda, p) \\
    \end{alignat*}
\f]

Simbody then integrates \f$ u \f$ and \f$ z \f$ using \f$ \dot{u} \f$ and \f$
\dot{z} \f$. If the kinematic constraints are obeyed in the initial state, then
theoretically, enforcing the constraints at the acceleration level (as done
above) should cause the accelerations to remain enforced at the position and
velocity levels. However, numerical integrators generate errors, causing the
constraints to no longer be satisfied at the position and velocity levels. To
fix this, Simbody projects the generalized coordinates and speeds
onto the "constraint manifold" (that is, the multidimensional surface on which
the system's kinematic constraints are satisfied; see SimTK::System::project()).

Handling kinematic constraints in direct collocation requires a different
approach, because we cannot perform an internal "projection" within the
direct collocation optimization problem. We use the method described by Posa et
al., 2015 (TODO)

In this scheme, the optimization solver searches for Lagrange multipliers that
satisfy the equations above. This means that, when we use Simbody to evaluate
multibody equations, we must tell Simbody what the multipliers are. However,
this flow of data does not fit with Simbody's realization scheme, in which
Simbody computes Lagrange multipliers itself. Some quantities such as joint
reaction loads depend on Lagrange multipliers, and it is essential that we use
the correct multipliers when computing such quantities; that is, the multipliers
from the optimization instead of those computed by Simbody. To circumvent this
issue, we employ two OpenSim Models: the original user-provided model with
kinematic constraints, and model in which all kinematic constraints are
disabled. We use the first (constrained) model to calculate kinematic constraint
violations and to convert the optimization solver's Lagrange multipliers into
body and mobilizer forces using the constrained model's constraint Jacobian.
Then we apply those multiplier-derived forces to the unconstrained model. The
unconstrained model is used in MocoCost and MocoPathConstraint, in which users
can safely employ joint reaction loads in their calculations.

Note however that MocoCosts and MocoPathConstraints do not have direct access
to the Lagrange multipliers; the unconstrained model does not have multipliers.

@subsection implimplicitmultibody Implicit multibody dynamics




@subsection implpreskin Prescribed kinematics

For a system without kinematic constraints, the equations of motion are:

\f[
M \dot{u} + f_{\mathrm{bias}} + \lambda_m = f_{\mathrm{app}}.
\f]

The Lagrange multipliers \f$ \lambda_m \f$ are the mobility forces required for
the system to follow the prescribed kinematics. In our case, we do not want any
ficticious forces generated, and so we require that \f$\lambda_m = 0\f$. Simbody
gives us access to these multipliers via
SimTK::SimbodyMatterSubsystem::findMotionForces(), and we constrain the output
of this function to be 0. Note that the only unknown in this equation is \f$
f_{\mathrm{app}} \f$; the other quantities are known because they only depend on
kinematics.

With kinematic constraints, the equations of motion are

\f[
M \dot{u} + f_{\mathrm{bias}} + \lambda_m + G^T \lambda_c = f_{\mathrm{app}}
\f]

\f$ G \f$ is the kinematic constraint Jacobian and \f$ \lambda_c \f$ are the
kiinematic constraint Langrange multipliers. We still require \f$ \lambda_m = 0
\f$ but we must allow the kinematic constraints to apply force. Applied forces
affect what the constraint forces must be. Consider a point mass with degrees of
freedom \f$ x \f$ and \f$ y \f$ and generalized forces \f$ F_x \f$ and \f$ F_y
\f$ constrained to the line \f$ y = x \f$ and with prescribed motion \f$ y(t) =
x(t) = \sin(t) \f$. Moco will solve for the forces \f$ F_x \f$ and \f$ F_y \f$
that can achieve this prescribed motion (by setting \f$ \lambda_m = 0 \f$ and
solving for \f$ f_{\mathrm{app}} \f$, and the Lagrange multiplier \f$ \lambda_c
\f$ will ensure that, regardless of the values of \f$ F_x \f$ and \f$ F_y \f$,
the mass will remain on the line.

*/
} // namespace OpenSim

